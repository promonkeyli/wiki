---
title: golang 协程
---
# goroutine

## 说明

* 概念：协程`goroutine`是由go运行时（`runtime`）管理的轻量级`线程`，形象比喻如下：

  * 进程：类似一家工厂

  * 线程：工厂里的生产线

  * 协程：生产线上的工人，非常轻量

* 优势

  * 极小内存消耗：`线程`通常需要`1-2MB`栈内存；`协程`初始只需要`2KB`，会更具需要自动伸缩

  * 极快切换速度：线程切换需要操作系统介入，开销大；协程切换，由go`调度器`完成，不经过内核，快如闪电

  * 海量并发：普通笔记本开几千个线程卡死，但是开启`100万`携程依然流畅运行

## 开启协程

启动一个协程很简单，调用函数前面添加`go`关键字

```go
func main() {
	a := 10
	b := 2

	// 执行求解两数之和的协程
	go sumTwoTask(a, b)

	// 执行求解两数乘积的协程
	go multiTwoTask(a, b)

	fmt.Println("主协程运行") // 只会输出这一句，然后程序结束
}

func sumTwoTask(a, b int) {
	fmt.Printf("协程-求解两数之和的值为：%d", a+b)
}

func multiTwoTask(a, b int) {
	fmt.Printf("协程-求解两数乘积的值为：%d", a*b)
}
```

上述代码你会发现只会打印"主协程运行"然后程序就退出了，子协程并没有打印，有一些规则如下：

* `main`函数执行完毕会立即关闭，不会管子协程是否运行

* 如果`main`函数中没有任何阻塞代码，子协程里的东西是不会打印的

所以得让主协程等待子协程干完活才能结束主协程，而让协程可控的方式有三种：

1. 等待同步：`sync.WaitGroup`
2. 通信控制：`channel`
3. 生命周期管理：`context`

下一篇先记录`等待同步`的使用方式